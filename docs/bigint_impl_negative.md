
# Negative 정수 표현 및 연산 지원


- 작성 날짜: 2025/6/11

## 배경

작성 날짜인 2025/6/11 기준으로 현재까지의 상황은 다음과 같습니다.

- 10진 표현으로 각 단위의 숫자(0~9)를 배열의 각 요소로 역순 저장하는 방식 사용
- 덧셈, 뺄셈 연산 구현

여기서 뺄셈 Subtract() 메소드의 구현에서, 연산 결과가 0 보다 작은 경우의 처리가 누락되어 있습니다.
음의 정수에 대한 지원은 원래 처음에 계획에는 없었지만, 이 부분이 그다지 큰 노력이 필요로 하는 것 같지 않고, 적어도 add/subtract 에 대해서는 완결성을 갖추는 것이 나쁘지 않다고 생각하여 진행합니다.


## 고려 사항

근래의 컴퓨터 구조에서는 숫자를 이진수로 관리하며 음수를 표현할 때에는 2의 보수를 사용합니다. 이렇게 하면 몇 가지 장점이 있습니다.
- "음수의 덧셈"과 "뺄셈"이 동일한 연산이 됨.
- 1의 보수를 사용하는 경우와 비교했을 때, 0을 표현하는 방법이 하나만 존재하여 모호성 없음.
- 부호를 의미하는 비트가 자연스럽게 생김 (MSB가 그 역할)
- 덧셈에서의 오버플로우 또한 자동으로 감지될 수 있음.
- ...

하지만, 위와 같은 보수 방식은 표현할 비트 크기가 한정되어 있는 경우에나 사용이 가능하며, 무한 자릿수를 지원하고자 하는 본 목표에는 적용이 어렵습니다.

## 해결책

거의 유일한 해결책은 'signed-magnitude' 라고 불리는 방법입니다. 음수인지 양수인지를 의미하는 비트 (또는 플래그)와, 절대값을 숫자로 표현하는 것입니다.

앞서 설명했던 2의 보수 표현 방식의 장점들이, 이 방법에서는 단점 또는 고민해야 할 문제가 됩니다. 각 항목 및 대안들은 다음과 같습니다.

- (단점) 0을 나타내는 경우가 두 가지 존재. 즉, 양의 0과 음의 0이 존재.
  - 적절히 조치하지 않으면 이로 인해 equal() 과 같은 연산에서 문제가 발생할 수 있음.
  - 대안으로는, 단 하나의 zero 표현만 허용하도록 내부 규칙을 정하고, 매번 연산 후에 Normalize() 하는 과정을 거치도록 하면 됨.
- (단점) 뺄셈 언더플로우 상황을 고려하여 관리해야 함.
  - 양의 작은 수에서 양의 큰수를 뺄셈 연산 하는 경우, 부호가 바뀌는 상황이 2의 보수 때 만틈 자연스럽지 않고 주의 깊게 관리해야 함.
  - 그 외에는 양의 최댓값 넘침, 음의 최소값 넘침은 발생하지 않음. (자릿수가 무한하기 때문)
- (장점) 인간의 사고과 유사하여 직관적으로 이해가 됨.

## 구현
TODO





